diff --git a/gson/src/main/java/com/google/gson/Gson.java b/gson/src/main/java/com/google/gson/Gson.java
index 62c8b0c6..2c8adfa6 100644
--- a/gson/src/main/java/com/google/gson/Gson.java
+++ b/gson/src/main/java/com/google/gson/Gson.java
@@ -54,6 +54,7 @@ import com.google.gson.internal.bind.ReflectiveTypeAdapterFactory;
 import com.google.gson.internal.bind.TypeAdapters;
 import com.google.gson.internal.sql.SqlTypesSupport;
 import com.google.gson.reflect.TypeToken;
+import com.google.gson.schema.JsonSchemaMatcher;
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonToken;
 import com.google.gson.stream.JsonWriter;
@@ -116,6 +117,7 @@ public final class Gson {
   static final FieldNamingStrategy DEFAULT_FIELD_NAMING_STRATEGY = FieldNamingPolicy.IDENTITY;
   static final ToNumberStrategy DEFAULT_OBJECT_TO_NUMBER_STRATEGY = ToNumberPolicy.DOUBLE;
   static final ToNumberStrategy DEFAULT_NUMBER_TO_NUMBER_STRATEGY = ToNumberPolicy.LAZILY_PARSED_NUMBER;
+  static final JsonSchemaMatcher DEFAULT_JSON_SCHEMA_MATCHER = JsonSchemaMatcher.ALLOW_EVERYTHING;
 
   private static final TypeToken<?> NULL_KEY_SURROGATE = TypeToken.get(Object.class);
   private static final String JSON_NON_EXECUTABLE_PREFIX = ")]}'\n";
@@ -156,6 +158,7 @@ public final class Gson {
   final List<TypeAdapterFactory> builderHierarchyFactories;
   final ToNumberStrategy objectToNumberStrategy;
   final ToNumberStrategy numberToNumberStrategy;
+  final JsonSchemaMatcher schemaMatcher;
 
   /**
    * Constructs a Gson object with default configuration. The default configuration has the
@@ -199,7 +202,8 @@ public final class Gson {
         DEFAULT_USE_JDK_UNSAFE,
         LongSerializationPolicy.DEFAULT, DEFAULT_DATE_PATTERN, DateFormat.DEFAULT, DateFormat.DEFAULT,
         Collections.<TypeAdapterFactory>emptyList(), Collections.<TypeAdapterFactory>emptyList(),
-        Collections.<TypeAdapterFactory>emptyList(), DEFAULT_OBJECT_TO_NUMBER_STRATEGY, DEFAULT_NUMBER_TO_NUMBER_STRATEGY);
+        Collections.<TypeAdapterFactory>emptyList(), DEFAULT_OBJECT_TO_NUMBER_STRATEGY, DEFAULT_NUMBER_TO_NUMBER_STRATEGY,
+        DEFAULT_JSON_SCHEMA_MATCHER);
   }
 
   Gson(Excluder excluder, FieldNamingStrategy fieldNamingStrategy,
@@ -211,7 +215,8 @@ public final class Gson {
       int timeStyle, List<TypeAdapterFactory> builderFactories,
       List<TypeAdapterFactory> builderHierarchyFactories,
       List<TypeAdapterFactory> factoriesToBeAdded,
-      ToNumberStrategy objectToNumberStrategy, ToNumberStrategy numberToNumberStrategy) {
+      ToNumberStrategy objectToNumberStrategy, ToNumberStrategy numberToNumberStrategy,
+      JsonSchemaMatcher schemaMatcher) {
     this.excluder = excluder;
     this.fieldNamingStrategy = fieldNamingStrategy;
     this.instanceCreators = instanceCreators;
@@ -232,6 +237,7 @@ public final class Gson {
     this.builderHierarchyFactories = builderHierarchyFactories;
     this.objectToNumberStrategy = objectToNumberStrategy;
     this.numberToNumberStrategy = numberToNumberStrategy;
+    this.schemaMatcher = schemaMatcher;
 
     List<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();
 
@@ -1062,6 +1068,16 @@ public final class Gson {
     return (T) fromJson(new JsonTreeReader(json), typeOfT);
   }
 
+  /**
+   * Checks whether the provided JSON instance matches the schema currently associated with this Gson object.
+   *
+   * @param instance a JSON element to be matched against the schema
+   * @return true if the instance matches the schema
+   */
+  public boolean matchesSchema(JsonElement instance) {
+    return schemaMatcher.matches(instance);
+  }
+
   static class FutureTypeAdapter<T> extends TypeAdapter<T> {
     private TypeAdapter<T> delegate;
 
diff --git a/gson/src/main/java/com/google/gson/GsonBuilder.java b/gson/src/main/java/com/google/gson/GsonBuilder.java
index 43318fb3..a3eb35bc 100644
--- a/gson/src/main/java/com/google/gson/GsonBuilder.java
+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java
@@ -32,19 +32,10 @@ import com.google.gson.internal.bind.TreeTypeAdapter;
 import com.google.gson.internal.bind.TypeAdapters;
 import com.google.gson.internal.sql.SqlTypesSupport;
 import com.google.gson.reflect.TypeToken;
+import com.google.gson.schema.JsonSchemaMatcher;
 import com.google.gson.stream.JsonReader;
 
-import static com.google.gson.Gson.DEFAULT_COMPLEX_MAP_KEYS;
-import static com.google.gson.Gson.DEFAULT_DATE_PATTERN;
-import static com.google.gson.Gson.DEFAULT_ESCAPE_HTML;
-import static com.google.gson.Gson.DEFAULT_JSON_NON_EXECUTABLE;
-import static com.google.gson.Gson.DEFAULT_LENIENT;
-import static com.google.gson.Gson.DEFAULT_NUMBER_TO_NUMBER_STRATEGY;
-import static com.google.gson.Gson.DEFAULT_OBJECT_TO_NUMBER_STRATEGY;
-import static com.google.gson.Gson.DEFAULT_PRETTY_PRINT;
-import static com.google.gson.Gson.DEFAULT_SERIALIZE_NULLS;
-import static com.google.gson.Gson.DEFAULT_SPECIALIZE_FLOAT_VALUES;
-import static com.google.gson.Gson.DEFAULT_USE_JDK_UNSAFE;
+import static com.google.gson.Gson.*;
 
 /**
  * <p>Use this builder to construct a {@link Gson} instance when you need to set configuration
@@ -101,6 +92,7 @@ public final class GsonBuilder {
   private boolean useJdkUnsafe = DEFAULT_USE_JDK_UNSAFE;
   private ToNumberStrategy objectToNumberStrategy = DEFAULT_OBJECT_TO_NUMBER_STRATEGY;
   private ToNumberStrategy numberToNumberStrategy = DEFAULT_NUMBER_TO_NUMBER_STRATEGY;
+  private JsonSchemaMatcher schemaMatcher = DEFAULT_JSON_SCHEMA_MATCHER;
 
   /**
    * Creates a GsonBuilder instance that can be used to build Gson with various configuration
@@ -137,6 +129,7 @@ public final class GsonBuilder {
     this.useJdkUnsafe = gson.useJdkUnsafe;
     this.objectToNumberStrategy = gson.objectToNumberStrategy;
     this.numberToNumberStrategy = gson.numberToNumberStrategy;
+    this.schemaMatcher = gson.schemaMatcher;
   }
 
   /**
@@ -377,6 +370,27 @@ public final class GsonBuilder {
     return this;
   }
 
+  /**
+   * Sets the Gson schema matcher that is used to verify JSON with the Gson.matchesSchema() method.
+   *
+   * @param schemaMatcher an instance of a JsonSchemaMatcher
+   * @return a reference to this {@code GsonBuilder} object to fulfill the "Builder" pattern
+   */
+  public GsonBuilder setSchemaMatcher(JsonSchemaMatcher schemaMatcher) {
+    this.schemaMatcher = schemaMatcher;
+    return this;
+  }
+
+  /**
+   * Disables the schema matcher. This is equivalent to setting the schema matcher to the "true" schema, i.e. allowing
+   * every schema.
+   *
+   * @return a reference to this {@code GsonBuilder} object to fulfill the "Builder" pattern
+   */
+  public GsonBuilder disableSchemaMatcher() {
+    return setSchemaMatcher(DEFAULT_JSON_SCHEMA_MATCHER);
+  }
+
   /**
    * Configures Gson to apply the passed in exclusion strategy during serialization.
    * If this method is invoked numerous times with different exclusion strategy objects
@@ -654,7 +668,8 @@ public final class GsonBuilder {
         generateNonExecutableJson, escapeHtmlChars, prettyPrinting, lenient,
         serializeSpecialFloatingPointValues, useJdkUnsafe, longSerializationPolicy,
         datePattern, dateStyle, timeStyle,
-        this.factories, this.hierarchyFactories, factories, objectToNumberStrategy, numberToNumberStrategy);
+        this.factories, this.hierarchyFactories, factories, objectToNumberStrategy, numberToNumberStrategy,
+        schemaMatcher);
   }
 
   private void addTypeAdaptersForDate(String datePattern, int dateStyle, int timeStyle,
diff --git a/gson/src/main/java/com/google/gson/schema/JsonSchemaMatcher.java b/gson/src/main/java/com/google/gson/schema/JsonSchemaMatcher.java
new file mode 100644
index 00000000..b9ee6710
--- /dev/null
+++ b/gson/src/main/java/com/google/gson/schema/JsonSchemaMatcher.java
@@ -0,0 +1,372 @@
+package com.google.gson.schema;
+
+import com.google.gson.*;
+import com.google.gson.stream.JsonReader;
+
+import java.io.Reader;
+import java.util.HashSet;
+import java.util.Set;
+
+/**
+ * The {@code JsonSchemaMatcher} class is responsible for matching a JSON schema against a JSON instance.
+ */
+public class JsonSchemaMatcher {
+
+  // The "true" schema matches any valid JSON
+  public static final JsonSchemaMatcher ALLOW_EVERYTHING = new JsonSchemaMatcher("true");
+
+  // The root of the schema file can be either a JSON object or a Boolean.
+  private final JsonElement schemaRoot;
+
+  /**
+   * Creates a new {@code JsonSchemaMatcher} instance from a valid schema JsonElement.
+   *
+   * @param jsonSchema the schema as a {@code JsonElement}.
+   */
+  public JsonSchemaMatcher(JsonElement jsonSchema) {
+    schemaRoot = jsonSchema;
+  }
+
+  /**
+   * Creates a new {@code JsonSchemaMatcher} instance from a valid schema string.
+   *
+   * @param jsonSchema the schema as a {@code String}.
+   */
+  public JsonSchemaMatcher(String jsonSchema) {
+    this(JsonParser.parseString(jsonSchema));
+  }
+
+  /**
+   * Creates a new {@code JsonSchemaMatcher} instance from a {@code Reader} of a valid schema.
+   *
+   * @param jsonSchema the {@code Reader} of a schema.
+   */
+  public JsonSchemaMatcher(Reader jsonSchema) {
+    this(JsonParser.parseReader(jsonSchema));
+  }
+
+  /**
+   * Creates a new {@code JsonSchemaMatcher} instance from a {@code JsonReader} of a valid schema.
+   *
+   * @param jsonSchema the {@code JsonReader} of a schema.
+   */
+  public JsonSchemaMatcher(JsonReader jsonSchema) {
+    this(JsonParser.parseReader(jsonSchema));
+  }
+
+  /**
+   * Checks that the JSON instance (or sub-instance) and the schema (or sub-schema) has matching types.
+   *
+   * @param instance the JSON instance (or sub-instance).
+   * @param schema   the schema (or sub-schema).
+   * @return
+   */
+  private boolean matchingTypes(JsonElement instance, JsonObject schema) {
+    // If the sub-schema does not have a "type" property then the instance can have any type.
+    if (!schema.has("type"))
+      return true;
+
+    String type = schema.get("type").getAsString();
+
+    switch (type) {
+      case "object":
+        return instance.isJsonObject();
+      case "array":
+        return instance.isJsonArray();
+      case "null":
+        return instance.isJsonNull();
+      case "boolean":
+        if (!instance.isJsonPrimitive())
+          return false;
+        return instance.getAsJsonPrimitive().isBoolean();
+      case "number":
+        if (!instance.isJsonPrimitive())
+          return false;
+        return instance.getAsJsonPrimitive().isNumber();
+      case "integer":
+        if (!instance.isJsonPrimitive())
+          return false;
+        if (!instance.getAsJsonPrimitive().isNumber())
+          return false;
+        return (instance.getAsJsonPrimitive().getAsDouble() % 1) == 0;
+      case "string":
+        if (!instance.isJsonPrimitive())
+          return false;
+        return instance.getAsJsonPrimitive().isString();
+    }
+
+    return false;
+  }
+
+  /**
+   * Checks that the JSON instance (or sub-instance) has one of the values defined by the enum property in the schema (or sub-schema).
+   *
+   * @param instance the JSON instance (or sub-instance).
+   * @param schema   the schema (or sub-schema).
+   * @return
+   */
+  private boolean matchingEnum(JsonElement instance, JsonObject schema) {
+    // If the sub-schema does not have an "enum" property then we will skip this check.
+    if (!schema.has("enum"))
+      return true;
+
+    // The value of the enum property must be an array.
+    JsonArray enumValues = schema.getAsJsonArray("enum");
+
+    // Check if the instance is equal to any of the enum values.
+    for (JsonElement enumValue : enumValues)
+      if (instance.equals(enumValue))
+        return true;
+
+    // If the instance is not equal to any of the enum values, then return false.
+    return false;
+  }
+
+
+  /**
+   * Matches an instance (or sub-instance) object against a schema (or sub-schema).
+   *
+   * @param instanceObject the instance (or sub-instance) object.
+   * @param schema         the schema (or sub-schema).
+   * @return true if an instance (or sub-instance) object matches against the sub-schema, otherwise false.
+   */
+  private boolean objectMatches(JsonObject instanceObject, JsonObject schema) {
+    // Check that the instance has all the required properties.
+    if (schema.has("required")) {
+      JsonArray requiredArray = schema.getAsJsonArray("required");
+
+      for (JsonElement required : requiredArray) {
+        if (!instanceObject.has(required.getAsString()))
+          return false;
+      }
+    }
+
+    // If the sub-schema does not have a "properties" property then the instance can have any properties it wants.
+    if (!schema.has("properties"))
+      return true;
+
+    JsonObject properties = schema.getAsJsonObject("properties");
+
+    // Check that each property in the sub-schema matches against the instance properties.
+    for (String key : properties.keySet()) {
+
+      // The instance is not required to have all the properties defined in the sub-schema.
+      if (!instanceObject.has(key))
+        continue;
+
+      if (!matches(instanceObject.get(key), properties.getAsJsonObject(key)))
+        return false;
+    }
+
+    return true;
+  }
+
+  /**
+   * Matches an instance (or sub-instance) array against a schema (or sub-schema).
+   *
+   * @param instanceArray the instance (or sub-instance) array.
+   * @param schema        the schema (or sub-schema).
+   * @return true if an instance (or sub-instance) array matches against the sub-schema, otherwise false.
+   */
+  private boolean arrayMatches(JsonArray instanceArray, JsonObject schema) {
+    // Check if the sub-schema has the "minItems" property and then the array must have
+    // at least as many elements specified by the "minItems" property.
+    if (schema.has("minItems") && instanceArray.size() < schema.get("minItems").getAsInt())
+      return false;
+
+    // Check if the sub-schema has the "uniqueItems" property and if it is true, if so, all elements in the array must be unique.
+    if (schema.has("uniqueItems") && schema.get("uniqueItems").getAsBoolean()) {
+      Set<JsonElement> found = new HashSet<>();
+
+      for (JsonElement element : instanceArray) {
+        // Check if the element has already been found, if so the element is not unique.
+        if (found.contains(element))
+          return false;
+        found.add(element);
+      }
+    }
+
+    // If the sub-schema does not have the "items" property then the array can contain any elements.
+    if (!schema.has("items"))
+      return true;
+
+    JsonElement items = schema.get("items");
+
+    // Special case if the value of the items key is set to false.
+    if (items.isJsonPrimitive() && !items.getAsBoolean())
+      return instanceArray.isEmpty();
+
+    // Check that each element in the instance matches against the "items" object.
+    for (JsonElement element : instanceArray) {
+      if (!matches(element, items.getAsJsonObject()))
+        return false;
+    }
+
+    return true;
+  }
+
+  /**
+   * Matches an instance (or sub-instance) primitive against a schema (or sub-schema).
+   *
+   * @param instancePrimitive the instance (or sub-instance) primitive.
+   * @param schema            the schema (or sub-schema).
+   * @return true if an instance (or sub-instance) primitive matches against the sub-schema, otherwise false.
+   */
+  private boolean primitiveMatches(JsonPrimitive instancePrimitive, JsonObject schema) {
+    if (instancePrimitive.isBoolean()) {
+      return booleanMatches(instancePrimitive.getAsBoolean(), schema);
+    } else if (instancePrimitive.isNumber()) {
+      return numberMatches(instancePrimitive.getAsNumber(), schema);
+    } else if (instancePrimitive.isString()) {
+      return stringMatches(instancePrimitive.getAsString(), schema);
+    } else if (instancePrimitive.isJsonNull()) {
+      return nullMatches(instancePrimitive.getAsJsonNull(), schema);
+    }
+    return false;
+  }
+
+  /**
+   * Matches an instance (or sub-instance) boolean against a schema (or sub-schema).
+   *
+   * @param instanceBool the instance (or sub-instance) boolean.
+   * @param schema       the schema (or sub-schema).
+   * @return true if an instance (or sub-instance) boolean matches against the sub-schema, otherwise false.
+   */
+  private boolean booleanMatches(boolean instanceBool, JsonObject schema) {
+    // For now, we have no rules for booleans.
+    return true;
+  }
+
+  /**
+   * Matches an instance (or sub-instance) number against a schema (or sub-schema).
+   *
+   * @param instanceNumber the instance (or sub-instance) number.
+   * @param schema         the schema (or sub-schema).
+   * @return true if an instance (or sub-instance) number matches against the sub-schema, otherwise false.
+   */
+  private boolean numberMatches(Number instanceNumber, JsonObject schema) {
+    if (schema.has("minimum")) {
+      double minimum = schema.get("minimum").getAsDouble();
+      if (instanceNumber.doubleValue() < minimum)
+        return false;
+    }
+
+    if (schema.has("maximum")) {
+      double maximum = schema.get("maximum").getAsDouble();
+      if (instanceNumber.doubleValue() > maximum)
+        return false;
+    }
+
+    if (schema.has("exclusiveMinimum")) {
+      double exclusiveMinimum = schema.get("exclusiveMinimum").getAsDouble();
+      if (instanceNumber.doubleValue() <= exclusiveMinimum)
+        return false;
+    }
+
+    if (schema.has("exclusiveMaximum")) {
+      double exclusiveMaximum = schema.get("exclusiveMaximum").getAsDouble();
+      if (instanceNumber.doubleValue() >= exclusiveMaximum)
+        return false;
+    }
+
+    return true;
+  }
+
+  /**
+   * Matches an instance (or sub-instance) string against a schema (or sub-schema).
+   *
+   * @param instanceString the instance (or sub-instance) string.
+   * @param schema         the schema (or sub-schema).
+   * @return true if an instance (or sub-instance) string matches against the sub-schema, otherwise false.
+   */
+  private boolean stringMatches(String instanceString, JsonObject schema) {
+    // For now, we have no rules for strings.
+    return true;
+  }
+
+  /**
+   * Matches an instance (or sub-instance) null against a schema (or sub-schema).
+   *
+   * @param instanceNull the instance (or sub-instance) null.
+   * @param schema       the schema (or sub-schema).
+   * @return true if the instance (or sub-instance) matches against the schema, otherwise false.
+   */
+  private boolean nullMatches(JsonNull instanceNull, JsonObject schema) {
+    // For now, we have no rules for nulls.
+    return true;
+  }
+
+  /**
+   * Matches an instance (or sub-instance) against a schema (or sub-schema).
+   *
+   * @param instance the instance (or sub-instance).
+   * @param schema   the schema (or sub-schema).
+   * @return true if the instance matches against the schema, otherwise false.
+   */
+  private boolean matches(JsonElement instance, JsonElement schema) {
+    if (schema.isJsonPrimitive())
+      return schema.getAsBoolean();
+
+    // If the sub-schema is not a boolean it must be an object.
+    JsonObject schemaObject = schema.getAsJsonObject();
+
+    // Check that the instance has the correct type if the type property is defined in the sub-schema.
+    if (!matchingTypes(instance, schemaObject))
+      return false;
+
+    // Check that the instance has one of the enum values if the enum property is defined in the sub-schema.
+    if (!matchingEnum(instance, schemaObject))
+      return false;
+
+    // Depending on the type of the instance we should perform the matching algorithm differently.
+    if (instance.isJsonObject()) {
+      return objectMatches(instance.getAsJsonObject(), schemaObject);
+    } else if (instance.isJsonArray()) {
+      return arrayMatches(instance.getAsJsonArray(), schemaObject);
+    } else if (instance.isJsonPrimitive()) {
+      return primitiveMatches(instance.getAsJsonPrimitive(), schemaObject);
+    } else {
+      return false;
+    }
+  }
+
+  /**
+   * Matches the schema against a JSON instance.
+   *
+   * @param jsonInstance the JSON instance as a {@code JsonElement}.
+   * @return true if the instance matches against the schema, otherwise false.
+   */
+  public boolean matches(JsonElement jsonInstance) {
+    return matches(jsonInstance, schemaRoot);
+  }
+
+  /**
+   * Matches the schema against a JSON instance.
+   *
+   * @param jsonInstance the JSON instance as a {@code String}.
+   * @return true if the instance matches against the schema, otherwise false.
+   */
+  public boolean matches(String jsonInstance) {
+    return matches(JsonParser.parseString(jsonInstance));
+  }
+
+  /**
+   * Matches the schema against a JSON instance.
+   *
+   * @param jsonInstance a {@code Reader} of a JSON instance.
+   * @return true if the instance matches against the schema, otherwise false.
+   */
+  public boolean matches(Reader jsonInstance) {
+    return matches(JsonParser.parseReader(jsonInstance));
+  }
+
+  /**
+   * Matches the schema against a JSON instance.
+   *
+   * @param jsonInstance a {@code JsonReader} of a JSON instance.
+   * @return true if the instance matches against the schema, otherwise false.
+   */
+  public boolean matches(JsonReader jsonInstance) {
+    return matches(JsonParser.parseReader(jsonInstance));
+  }
+}
diff --git a/gson/src/main/java/com/google/gson/schema/JsonSchemaValidator.java b/gson/src/main/java/com/google/gson/schema/JsonSchemaValidator.java
new file mode 100644
index 00000000..506230c1
--- /dev/null
+++ b/gson/src/main/java/com/google/gson/schema/JsonSchemaValidator.java
@@ -0,0 +1,274 @@
+package com.google.gson.schema;
+
+import com.google.gson.JsonArray;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import com.google.gson.JsonPrimitive;
+
+import java.net.URI;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.function.Function;
+
+public abstract class JsonSchemaValidator {
+    /**
+     * provides validation of an element as a valid JSON schema.
+     * @param schema the schema root
+     * @throws SchemaValidationException if the schema does not fulfill the requirements specified on
+     * https://datatracker.ietf.org/doc/html/draft-bhutton-json-schema-00
+     */
+    public static void validate(JsonElement schema) throws SchemaValidationException {
+        if (validateSchemaRootType(schema)) return;
+        JsonObject schemaRoot = schema.getAsJsonObject();
+        verifyTypeField(schemaRoot, MemberTypes.OBJECT);
+        validateSchemaNode(schema);
+    }
+
+    static boolean validateSchemaRootType(JsonElement schema) throws SchemaValidationException {
+        boolean isObject = schema.isJsonObject();
+        if (!isObject){
+            // if schema root is not an Object, it must be a boolean
+            try {
+                schema.getAsBoolean();
+            } catch (RuntimeException e){
+                throw new SchemaValidationException("Schema is not valid");
+            }
+            return true;
+        }
+        return false;
+    }
+
+    static void validateSchemaNode(JsonElement schemaNode) throws SchemaValidationException {
+        if(!schemaNode.isJsonObject()) {
+            throw new SchemaValidationException("Schema node is not a JSON Object");
+        }
+
+        JsonObject object = schemaNode.getAsJsonObject();
+        validateOptionalURIField("$schema", object);
+        validateOptionalURIField("$id", object);
+        validateTypeField(object);
+
+        verifyAndGetFieldOrDefault(object, "description", JsonElement::getAsString, "");
+        verifyAndGetFieldOrDefault(object, "title", JsonElement::getAsString, "");
+
+        JsonElement types = object.get("type");
+        if (types.isJsonArray()) {
+            JsonArray list = types.getAsJsonArray();
+            if (list.isEmpty()) {
+                throw new SchemaValidationException("Type not allowed to be an empty array");
+            }
+            for (JsonElement type : types.getAsJsonArray()) {
+                String cleanedType = type.getAsString().trim().toUpperCase();
+                validateMemberType(MemberTypes.valueOf(cleanedType), object);
+            }
+            return;
+        }
+        String cleanedType = types.getAsString().trim().toUpperCase();
+        validateMemberType(MemberTypes.valueOf(cleanedType), object);
+    }
+
+    static void validateMemberType(MemberTypes memberType, JsonObject schemaNode) throws SchemaValidationException{
+        switch (memberType) {
+            case NUMBER:
+            case INTEGER:
+                validateNumberAndInteger(schemaNode);
+                break;
+            case STRING:
+                validateString(schemaNode);
+                break;
+            case OBJECT:
+                validateObject(schemaNode);
+                break;
+            case ARRAY:
+                validateArray(schemaNode);
+                break;
+            default:
+                break;
+        }
+    }
+
+    static void validateString(JsonObject schemaNode) throws SchemaValidationException {
+        int maxLength = verifyAndGetFieldOrDefault(schemaNode, "maxLength", JsonElement::getAsInt,  Integer.MAX_VALUE);
+        if (maxLength < 0){
+            throw new SchemaValidationException("\"maxLength\" must be greater than 0");
+        }
+        int minLength = verifyAndGetFieldOrDefault(schemaNode, "minLength", JsonElement::getAsInt,  Integer.MAX_VALUE);
+        if (minLength < 0){
+            throw new SchemaValidationException("\"minLength\" must be greater than 0");
+        }
+
+        verifyAndGetFieldOrDefault(schemaNode, "pattern", JsonElement::getAsString, "");
+    }
+
+    static void validateNumberAndInteger(JsonObject schemaNode) throws SchemaValidationException {
+        verifyAndGetFieldOrDefault(schemaNode, "exclusiveMinimum", JsonElement::getAsDouble,  0.0);
+        verifyAndGetFieldOrDefault(schemaNode, "exclusiveMaximum", JsonElement::getAsDouble,  0.0);
+        verifyAndGetFieldOrDefault(schemaNode, "minimum", JsonElement::getAsDouble,  0.0);
+        verifyAndGetFieldOrDefault(schemaNode, "maximum", JsonElement::getAsDouble,  0.0);
+
+        double multipleOf = verifyAndGetFieldOrDefault(schemaNode,
+                "multipleOf",
+                JsonElement::getAsDouble,
+                1.0);
+        if (multipleOf <= 0){
+            throw new SchemaValidationException("\"multipleOf\" must be strictly greater than 0");
+        }
+
+    }
+
+    static void validateObject(JsonObject schemaNode) throws SchemaValidationException {
+        try {
+            JsonObject childNode = schemaNode.getAsJsonObject("properties");
+            HashMap<String, String> propertyFields = new HashMap<>();
+            for (String key : childNode.keySet()) {
+                if(validateSchemaRootType(childNode.get(key)))
+                    continue;
+                validateSchemaNode(childNode.get(key));
+                propertyFields.put(key, key);
+            }
+            if(schemaNode.has("required")) {
+                JsonArray requiredFields = schemaNode.getAsJsonArray("required");
+                for (JsonElement element : requiredFields) {
+                    assert(propertyFields.containsKey(element.getAsString()));
+                }
+            }
+        } catch (SchemaValidationException ex) {
+            throw ex;
+        } catch (AssertionError ex) {
+            throw new SchemaValidationException("Required properties not present in schema");
+        } catch (Throwable ex) {
+            throw new SchemaValidationException(ex);
+        }
+    }
+
+    static void validateArray(JsonObject schemaNode) throws SchemaValidationException {
+        if (schemaNode.has("items")){
+            validateSchemaNode(schemaNode.getAsJsonObject("items"));
+        }
+        if (schemaNode.has("contains")){
+            validateSchemaNode(schemaNode.getAsJsonObject("contains"));
+        }
+        if ((!schemaNode.has("items") || schemaNode.getAsJsonObject("items").keySet().isEmpty()) &&
+                !schemaNode.has("contains")){
+            throw new SchemaValidationException("Empty \"items\" object requires \"contains\" keyword");
+        }
+
+        if (schemaNode.has("prefixItems")){
+            JsonArray prefixItemsArray = schemaNode.getAsJsonArray("prefixItems");
+            if (prefixItemsArray.isEmpty()){
+                throw new SchemaValidationException("\"prefixItems\" may not be empty");
+            }
+            for (JsonElement el : prefixItemsArray){
+                validateSchemaNode(el.getAsJsonObject());
+            }
+        }
+
+        verifyAndGetFieldOrDefault(schemaNode, "minItems", JsonElement::getAsInt,  0);
+        verifyAndGetFieldOrDefault(schemaNode, "uniqueItems", JsonElement::getAsBoolean, true);
+
+        if (schemaNode.has("uniqueItems")){
+            try {
+                schemaNode.getAsJsonPrimitive("uniqueItems").getAsBoolean();
+            } catch (Throwable throwable){
+                throw new SchemaValidationException("\"uniqueItems\" must be a boolean", throwable);
+            }
+        }
+
+    }
+
+    static void validateTypeField(JsonObject schema) throws SchemaValidationException {
+        JsonElement type = schema.get("type");
+        if (type == null){
+            throw new SchemaValidationException("Type not defined");
+        }
+        boolean isArray = type.isJsonArray();
+        if (isArray){
+            JsonArray array = type.getAsJsonArray();
+            if (array.isEmpty())
+                throw new SchemaValidationException();
+            try {
+                HashSet<MemberTypes> memberSet = new HashSet<>();
+                for (JsonElement member : array) {
+                    MemberTypes parsedType = MemberTypes.valueOf(member.getAsString().trim().toUpperCase());
+                    if (memberSet.contains(parsedType)) {
+                        throw new SchemaValidationException("Type array may not contain multiple instances of the same type");
+                    }
+                    memberSet.add(parsedType);
+                }
+            } catch (IllegalArgumentException ex) {
+                throw new SchemaValidationException("Type not allowed", ex);
+            }
+            return;
+        }
+        try {
+            MemberTypes.valueOf(type.getAsString().trim().toUpperCase());
+        } catch (IllegalArgumentException ex) {
+            throw new SchemaValidationException("Type not allowed", ex);
+        }
+    }
+
+    static void verifyTypeField(JsonObject schemaNode, MemberTypes requiredType) throws SchemaValidationException {
+        JsonElement type = schemaNode.get("type");
+        MemberTypes memberType;
+        try {
+            String objectType = type.getAsString().trim().toUpperCase();
+            memberType = MemberTypes.valueOf(objectType);
+        } catch (Throwable ex) {
+            throw new SchemaValidationException(ex);
+        }
+
+        if (memberType != requiredType) {
+            throw new SchemaValidationException();
+        }
+    }
+
+    private static <T> T verifyAndGetFieldOrDefault(JsonObject schemaNode,
+                                                    String key,
+                                                    Function<JsonElement, T> verificationFunction,
+                                                    T defaultValue) throws SchemaValidationException {
+        if (schemaNode.has(key)) {
+            try{
+                return verificationFunction.apply(schemaNode.getAsJsonPrimitive(key));
+            } catch (RuntimeException e){
+                throw new SchemaValidationException("\"" + key + "\" must be a " + defaultValue.getClass().getSimpleName(), e);
+            }
+        }
+        return defaultValue;
+    }
+
+    static void validateOptionalURIField(String memberName, JsonObject schemaRoot) throws SchemaValidationException {
+        if (schemaRoot.has(memberName)){
+            JsonPrimitive schema = schemaRoot.getAsJsonPrimitive(memberName);
+            try{
+                URI.create(schema.getAsString());
+            } catch (IllegalArgumentException e){
+                throw new SchemaValidationException(memberName + " is not a valid URI", e);
+            }
+        }
+    }
+
+    enum MemberTypes{
+        STRING,
+        NUMBER,
+        INTEGER,
+        OBJECT,
+        ARRAY,
+        BOOLEAN,
+        NULL
+    }
+
+    static class SchemaValidationException extends Exception{
+        public SchemaValidationException(){
+            super();
+        }
+        public SchemaValidationException(String message) {
+            super(message);
+        }
+        public SchemaValidationException(String message, Throwable throwable) {
+            super(message, throwable);
+        }
+        public SchemaValidationException(Throwable ex){
+            super(ex);
+        }
+    }
+}
diff --git a/gson/src/main/java/module-info.java b/gson/src/main/java/module-info.java
index 0134c9dc..a8e0900b 100644
--- a/gson/src/main/java/module-info.java
+++ b/gson/src/main/java/module-info.java
@@ -7,8 +7,9 @@ module com.google.gson {
 	exports com.google.gson.annotations;
 	exports com.google.gson.reflect;
 	exports com.google.gson.stream;
+    exports com.google.gson.schema;
 
-	// Optional dependency on java.sql
+    // Optional dependency on java.sql
 	requires static java.sql;
 
 	// Optional dependency on jdk.unsupported for JDK's sun.misc.Unsafe
diff --git a/gson/src/test/java/com/google/gson/GsonTest.java b/gson/src/test/java/com/google/gson/GsonTest.java
index 186ceec9..26f84e69 100644
--- a/gson/src/test/java/com/google/gson/GsonTest.java
+++ b/gson/src/test/java/com/google/gson/GsonTest.java
@@ -17,6 +17,7 @@
 package com.google.gson;
 
 import com.google.gson.internal.Excluder;
+import com.google.gson.schema.JsonSchemaMatcher;
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonWriter;
 import com.google.gson.stream.MalformedJsonException;
@@ -56,7 +57,8 @@ public final class GsonTest extends TestCase {
         true, true, false, true, LongSerializationPolicy.DEFAULT, null, DateFormat.DEFAULT,
         DateFormat.DEFAULT, new ArrayList<TypeAdapterFactory>(),
         new ArrayList<TypeAdapterFactory>(), new ArrayList<TypeAdapterFactory>(),
-        CUSTOM_OBJECT_TO_NUMBER_STRATEGY, CUSTOM_NUMBER_TO_NUMBER_STRATEGY);
+        CUSTOM_OBJECT_TO_NUMBER_STRATEGY, CUSTOM_NUMBER_TO_NUMBER_STRATEGY,
+        Gson.DEFAULT_JSON_SCHEMA_MATCHER);
 
     assertEquals(CUSTOM_EXCLUDER, gson.excluder);
     assertEquals(CUSTOM_FIELD_NAMING_STRATEGY, gson.fieldNamingStrategy());
@@ -70,7 +72,8 @@ public final class GsonTest extends TestCase {
         true, true, false, true, LongSerializationPolicy.DEFAULT, null, DateFormat.DEFAULT,
         DateFormat.DEFAULT, new ArrayList<TypeAdapterFactory>(),
         new ArrayList<TypeAdapterFactory>(), new ArrayList<TypeAdapterFactory>(),
-        CUSTOM_OBJECT_TO_NUMBER_STRATEGY, CUSTOM_NUMBER_TO_NUMBER_STRATEGY);
+        CUSTOM_OBJECT_TO_NUMBER_STRATEGY, CUSTOM_NUMBER_TO_NUMBER_STRATEGY,
+        Gson.DEFAULT_JSON_SCHEMA_MATCHER);
 
     Gson clone = original.newBuilder()
         .registerTypeAdapter(Object.class, new TestTypeAdapter())
@@ -152,4 +155,32 @@ public final class GsonTest extends TestCase {
     assertEquals("test", jsonReader.nextString());
     jsonReader.close();
   }
+
+  public void testSchemaMatcherFailing() {
+    JsonSchemaMatcher matcher = new JsonSchemaMatcher("false");
+    JsonElement instance = JsonParser.parseString("{\"foo\": \"bar\"}");
+    Gson gson = new GsonBuilder()
+            .setSchemaMatcher(matcher)
+            .create();
+    assertFalse(gson.matchesSchema(instance));
+  }
+
+  public void testSchemaMatcherSuccess() {
+    JsonSchemaMatcher matcher = new JsonSchemaMatcher("true");
+    JsonElement instance = JsonParser.parseString("{\"foo\": \"bar\"}");
+    Gson gson = new GsonBuilder()
+            .setSchemaMatcher(matcher)
+            .create();
+    assertTrue(gson.matchesSchema(instance));
+  }
+
+  public void testDisableSchemaMatcher() {
+    JsonSchemaMatcher matcher = new JsonSchemaMatcher("false");
+    JsonElement instance = JsonParser.parseString("{\"foo\": \"bar\"}");
+    Gson gson = new GsonBuilder()
+            .setSchemaMatcher(matcher)
+            .disableSchemaMatcher()
+            .create();
+    assertTrue(gson.matchesSchema(instance));
+  }
 }
diff --git a/gson/src/test/java/com/google/gson/schema/JsonSchemaMatcherTest.java b/gson/src/test/java/com/google/gson/schema/JsonSchemaMatcherTest.java
new file mode 100644
index 00000000..204aa0b7
--- /dev/null
+++ b/gson/src/test/java/com/google/gson/schema/JsonSchemaMatcherTest.java
@@ -0,0 +1,475 @@
+/*
+ * Copyright (C) 2008 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.gson.schema;
+
+import com.google.gson.JsonArray;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import com.google.gson.JsonParser;
+import com.google.gson.stream.JsonReader;
+import junit.framework.TestCase;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import java.io.Reader;
+import java.io.StringReader;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+@RunWith(JUnit4.class)
+public class JsonSchemaMatcherTest extends TestCase {
+
+  private String objectSchema;
+
+  private String arraySchema;
+
+  private String numberSchema;
+
+  private String exclusiveNumberSchema;
+
+  private String enumSchema;
+
+  private String enumInstanceSuccessful = "\"hello\"";
+
+  private String enumInstanceSuccessful2 = "23";
+
+  private String enumInstanceSuccessful3 = "true";
+
+  private String enumInstanceFailing = "\"bye\"";
+
+  private String enumInstanceFailing2 = "24";
+
+  private String enumInstanceFailing3 = "false";
+
+  private String enumInstanceFailing4 = "null";
+
+  /**
+   * The following setup function prepares this schema:
+   *   {"type":"object","properties":{"obj2":{"type":"object","properties":{"nested":{"type":"object","properties":{"veryNested1":{"type":"object"},"veryNested2":{"type":"object"}},"required":["veryNested2"]}},"required":["nested"]},"obj1":{"type":"object","properties":{"nested":{"type":"object"}}}},"required":["obj2"]}
+   */
+  @Before
+  public void createObjectSchema() {
+    JsonSchemaObject schema = new JsonSchemaObject();
+    schema.addProperty(
+            "obj1",
+            new JsonSchemaObject().addProperty("nested", new JsonSchemaObject())
+    );
+    schema.addRequiredProperty(
+            "obj2",
+            new JsonSchemaObject().addRequiredProperty(
+                    "nested",
+                    new JsonSchemaObject().addProperty(
+                            "veryNested1",
+                            new JsonSchemaObject()
+                    ).addRequiredProperty(
+                            "veryNested2",
+                            new JsonSchemaObject()
+                    )
+            )
+    );
+    objectSchema = schema.toJsonElement().toString();
+  }
+
+  /**
+   * The following setup function prepares this schema:
+   *    {"type":"array","items":{"type":"object"},"minItems":2,"uniqueItems":true}
+   */
+  @Before
+  public void createArraySchema() {
+    JsonSchemaArray schema = new JsonSchemaArray();
+    schema.setMinItems(2);
+    schema.setUniqueItems(true);
+    schema.setItemType("object");
+    arraySchema = schema.toJsonElement().toString();
+  }
+
+  /**
+   * The following setup function prepares this schema:
+   *    {"type":"number","minimum":1,"maximum":3}
+   */
+  @Before
+  public void createNumberSchema() {
+    JsonSchemaNumber schema = new JsonSchemaNumber();
+    schema.setMinimum(1);
+    schema.setMaximum(3);
+    numberSchema = schema.toJsonElement().toString();
+  }
+
+  /**
+   * The following setup function prepares this schema:
+   *    {"type":"number","exclusiveMinimum":1,"exclusiveMaximum":3}
+   */
+  @Before
+  public void createExclusiveNumberSchema() {
+    JsonSchemaNumber schema = new JsonSchemaNumber();
+    schema.setExclusiveMinimum(1);
+    schema.setExclusiveMaximum(3);
+    exclusiveNumberSchema = schema.toJsonElement().toString();
+  }
+
+  /**
+   * The following setup function prepares this schema:
+   *    {"enum": ["hello", 23, true]}
+   */
+  @Before
+  public void createEnumSchema() {
+    JsonSchemaEnum schema = new JsonSchemaEnum();
+    schema.addValue("hello");
+    schema.addValue(23);
+    schema.addValue(true);
+    enumSchema = schema.toJsonElement().toString();
+  }
+
+  @Test
+  public void testMatcherCanSuccessfullyValidateAPassingSchema() {
+    JsonSchemaMatcher matcher = new JsonSchemaMatcher(objectSchema);
+
+    String jsonToValidate = "{\n" +
+            "    \"obj1\": {},\n" +
+            "    \"obj2\": {\n" +
+            "        \"nested\": {\n" +
+            "            \"veryNested1\": {},\n" +
+            "            \"veryNested2\": {}\n" +
+            "        }\n" +
+            "    }\n" +
+            "}";
+
+    assertTrue(matcher.matches(jsonToValidate));
+  }
+
+  @Test
+  public void testMatcherCanValidateSchemaWithoutTypes() {
+    JsonSchemaMatcher matcher = new JsonSchemaMatcher(objectSchema);
+
+    String jsonToValidate = "{\n" +
+            "    \"obj2\": {\n" +
+            "        \"nested\": {\n" +
+            "            \"veryNested2\": {}\n" +
+            "        }\n" +
+            "    }\n" +
+            "}";
+
+    assertTrue(matcher.matches(jsonToValidate));
+  }
+
+  @Test
+  public void testMatcherReturnsFalseIfProvidedStringDoesNotMatchSchema() {
+    JsonSchemaMatcher matcher = new JsonSchemaMatcher(objectSchema);
+
+    // "obj1" has the wrong type of property "nested" it should be an object but is an integer.
+    String json1 = "{\n" +
+            "    \"obj1\": {\n" +
+            "        \"nested\": 2\n" +
+            "    },\n" +
+            "    \"obj2\": {\n" +
+            "        \"nested\": {\n" +
+            "            \"veryNested1\": {},\n" +
+            "            \"veryNested2\": {}\n" +
+            "        }\n" +
+            "    }\n" +
+            "}";
+
+    // "obj2" does not contain the required property "veryNested2".
+    String json2 = "{\n" +
+            "    \"obj1\": {},\n" +
+            "    \"obj2\": {\n" +
+            "        \"nested\": {\n" +
+            "            \"veryNested1\": {}\n" +
+            "        }\n" +
+            "    }\n" +
+            "}";
+
+    assertFalse(matcher.matches(json1));
+    assertFalse(matcher.matches(json2));
+  }
+
+  @Test
+  public void testMatcherCanSuccessfullyMatchAValidArraySchema() {
+    JsonSchemaMatcher matcher = new JsonSchemaMatcher(arraySchema);
+
+    String json = "[\n" +
+            "    {},\n" +
+            "    { \"obj\": {}}\n" +
+            "]";
+
+    assertTrue(matcher.matches(json));
+  }
+
+  @Test
+  public void testJsonDoesNotPassIfNotItemsAreNotUniqueAndUniqueIsARequirement() {
+    JsonSchemaMatcher matcher = new JsonSchemaMatcher(arraySchema);
+
+    String json = "[\n" +
+            "    {},\n" +
+            "    {}\n" +
+            "]";
+
+    assertFalse(matcher.matches(json));
+  }
+
+  @Test
+  public void testArrayMinItemsFailing() {
+    JsonSchemaMatcher matcher = new JsonSchemaMatcher(arraySchema);
+
+    // Not enough items
+    String json = "[\n" +
+            "    {}\n" +
+            "]";
+
+    assertFalse(matcher.matches(json));
+  }
+
+  @Test
+  public void testNumberMinMax() {
+    JsonSchemaMatcher matcher = new JsonSchemaMatcher(numberSchema);
+    assertTrue(matcher.matches("1"));
+    assertTrue(matcher.matches("2"));
+    assertTrue(matcher.matches("3"));
+  }
+
+  @Test
+  public void testNumberMinMaxFailingTooSmall() {
+    JsonSchemaMatcher matcher = new JsonSchemaMatcher(numberSchema);
+    assertFalse(matcher.matches("0"));
+  }
+
+  @Test
+  public void testNumberMinMaxFailingTooLarge() {
+    JsonSchemaMatcher matcher = new JsonSchemaMatcher(numberSchema);
+    assertFalse(matcher.matches("4"));
+  }
+
+  @Test
+  public void testNumberExclusiveMinMaxSuccessful() {
+    JsonSchemaMatcher matcher = new JsonSchemaMatcher(exclusiveNumberSchema);
+    assertTrue(matcher.matches("2"));
+  }
+
+  @Test
+  public void testNumberExclusiveMinMaxFailingTooSmall() {
+    JsonSchemaMatcher matcher = new JsonSchemaMatcher(exclusiveNumberSchema);
+    assertFalse(matcher.matches("1"));
+  }
+
+  @Test
+  public void testNumberExclusiveMinMaxFailingTooLarge() {
+    JsonSchemaMatcher matcher = new JsonSchemaMatcher(exclusiveNumberSchema);
+    assertFalse(matcher.matches("3"));
+  }
+
+  @Test
+  public void testReaderAPI() {
+    Reader schemaReader = new StringReader("true");
+    Reader instanceReader = new StringReader("{}");
+    JsonSchemaMatcher matcher = new JsonSchemaMatcher(schemaReader);
+    assertTrue(matcher.matches(instanceReader));
+  }
+
+  @Test
+  public void testJsonReaderAPI() {
+    JsonReader schemaJsonReader = new JsonReader(new StringReader("true"));
+    JsonReader instanceJsonReader = new JsonReader(new StringReader("{}"));
+    JsonSchemaMatcher matcher = new JsonSchemaMatcher(schemaJsonReader);
+    assertTrue(matcher.matches(instanceJsonReader));
+  }
+
+  @Test
+  public void testStringAPI() {
+    String schemaString = "true";
+    String instanceString = "{}";
+    JsonSchemaMatcher matcher = new JsonSchemaMatcher(schemaString);
+    assertTrue(matcher.matches(instanceString));
+  }
+
+  @Test
+  public void testJsonElementAPI() {
+    JsonElement schemaJsonElement = JsonParser.parseString("true");
+    JsonElement instanceJsonElement = JsonParser.parseString("{}");
+    JsonSchemaMatcher matcher = new JsonSchemaMatcher(schemaJsonElement);
+    assertTrue(matcher.matches(instanceJsonElement));
+  }
+
+  @Test
+  public void testMatcherCanSuccessfullyValidateStringsThatMatchEnumSchema() {
+    JsonSchemaMatcher matcher = new JsonSchemaMatcher(enumSchema);
+    assertTrue(matcher.matches("hello"));
+    assertTrue(matcher.matches("23"));
+    assertTrue(matcher.matches("true"));
+  }
+
+  @Test
+  public void testMatcherCanSuccessfullyValidateStringsThatDoNotMatchEnumSchema() {
+    JsonSchemaMatcher matcher = new JsonSchemaMatcher(enumSchema);
+    assertFalse(matcher.matches("bye"));
+    assertFalse(matcher.matches("24"));
+    assertFalse(matcher.matches("false"));
+    assertFalse(matcher.matches("null"));
+  }
+}
+
+abstract class JsonSchemaElement {
+
+  public abstract JsonElement toJsonElement();
+
+  public String toString() {
+    return toJsonElement().getAsString();
+  }
+}
+
+class JsonSchemaObject extends JsonSchemaElement {
+  Map<String, JsonSchemaElement> properties = new HashMap<>();
+  List<String> required = new ArrayList<>();
+
+  public JsonSchemaObject addProperty(String name, JsonSchemaElement element) {
+    properties.put(name, element);
+    return this;
+  }
+
+  public JsonSchemaObject addRequiredProperty(String name, JsonSchemaElement element) {
+    properties.put(name, element);
+    required.add(name);
+    return this;
+  }
+
+  public JsonElement toJsonElement() {
+    JsonObject el = new JsonObject();
+    JsonObject props = new JsonObject();
+    for (String key : properties.keySet()) {
+      props.add(key, properties.get(key).toJsonElement());
+    }
+    el.addProperty("type", "object");
+    if (props.size() != 0) {
+      el.add("properties", props);
+    }
+    if (!required.isEmpty()) {
+      JsonArray arr = new JsonArray();
+      for (String key : required) {
+        arr.add(key);
+      }
+      el.add("required", arr);
+    }
+    return el;
+  }
+}
+
+class JsonSchemaArray extends JsonSchemaElement {
+  private String itemType;
+  private Integer minItems = null;
+  private Boolean uniqueItems = null;
+
+  public void setItemType(String itemType) {
+    this.itemType = itemType;
+  }
+
+  public void setMinItems(Integer minItems) {
+    this.minItems = minItems;
+  }
+
+  public void setUniqueItems(Boolean uniqueItems) {
+    this.uniqueItems = uniqueItems;
+  }
+
+  public JsonElement toJsonElement() {
+    JsonObject el = new JsonObject();
+    el.addProperty("type", "array");
+
+    JsonObject items = new JsonObject();
+    items.addProperty("type", itemType);
+
+    el.add("items", items);
+
+    if (minItems != null) {
+      el.addProperty("minItems", minItems);
+    }
+    if (uniqueItems != null) {
+      el.addProperty("uniqueItems", uniqueItems);
+    }
+    return el;
+  }
+}
+
+class JsonSchemaNumber extends JsonSchemaElement {
+  private Integer minimum = null;
+  private Integer maximum = null;
+  private Integer exclusiveMinimum = null;
+  private Integer exclusiveMaximum = null;
+
+  public void setMinimum(Integer minimum) {
+    this.minimum = minimum;
+  }
+
+  public void setMaximum(Integer maximum) {
+    this.maximum = maximum;
+  }
+
+  public void setExclusiveMinimum(Integer exclusiveMinimum) {
+    this.exclusiveMinimum = exclusiveMinimum;
+  }
+
+  public void setExclusiveMaximum(Integer exclusiveMaximum) {
+    this.exclusiveMaximum = exclusiveMaximum;
+  }
+
+  public JsonElement toJsonElement() {
+    JsonObject el = new JsonObject();
+    el.addProperty("type", "number");
+
+    if (minimum != null) {
+      el.addProperty("minimum", minimum);
+    }
+    if (maximum != null) {
+      el.addProperty("maximum", maximum);
+    }
+    if (exclusiveMinimum != null) {
+      el.addProperty("exclusiveMinimum", exclusiveMinimum);
+    }
+    if (exclusiveMaximum != null) {
+      el.addProperty("exclusiveMaximum", exclusiveMaximum);
+    }
+    return el;
+  }
+}
+
+class JsonSchemaEnum extends JsonSchemaElement {
+  List<Object> allowed = new ArrayList<>();
+
+  public void addValue(Object val) {
+    allowed.add(val);
+  }
+
+  public JsonElement toJsonElement() {
+    JsonObject el = new JsonObject();
+
+    JsonArray arr = new JsonArray();
+    for (Object val : allowed) {
+      if (val instanceof Boolean) {
+        arr.add((Boolean) val);
+      } else if (val instanceof String) {
+        arr.add((String) val);
+      } else if (val instanceof Integer) {
+        arr.add((Integer) val);
+      }
+    }
+
+    el.add("enum", arr);
+    return el;
+  }
+}
diff --git a/gson/src/test/java/com/google/gson/schema/JsonSchemaValidatorTest.java b/gson/src/test/java/com/google/gson/schema/JsonSchemaValidatorTest.java
new file mode 100644
index 00000000..9353e5cf
--- /dev/null
+++ b/gson/src/test/java/com/google/gson/schema/JsonSchemaValidatorTest.java
@@ -0,0 +1,175 @@
+package com.google.gson.schema;
+
+import com.google.gson.JsonElement;
+import com.google.gson.JsonParser;
+import com.google.gson.schema.JsonSchemaValidator;
+import org.junit.Assert;
+import org.junit.Test;
+
+public class JsonSchemaValidatorTest {
+
+    @Test
+    public void testValidate() throws JsonSchemaValidator.SchemaValidationException {
+        JsonElement root = JsonParser.parseString(
+                "{\n" +
+                        "  \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n" +
+                        "  \"$id\": \"https://example.com/product.schema.json\",\n" +
+                        "  \"title\": \"Product\",\n" +
+                        "  \"description\": \"A product from Acme's catalog\",\n" +
+                        "  \"type\": \"object\",\n" +
+                        "  \"properties\": {\n" +
+                        "    \"productId\": {\n" +
+                        "      \"description\": \"The unique identifier for a product\",\n" +
+                        "      \"type\": \"integer\"\n" +
+                        "    },\n" +
+                        "    \"productName\": {\n" +
+                        "      \"description\": \"Name of the product\",\n" +
+                        "      \"type\": \"string\"\n" +
+                        "    },\n" +
+                        "    \"price\": {\n" +
+                        "      \"description\": \"The price of the product\",\n" +
+                        "      \"type\": \"number\",\n" +
+                        "      \"exclusiveMinimum\": 0\n" +
+                        "    },\n" +
+                        "    \"tags\": {\n" +
+                        "      \"description\": \"Tags for the product\",\n" +
+                        "      \"type\": \"array\",\n" +
+                        "      \"items\": {\n" +
+                        "        \"type\": \"string\"\n" +
+                        "      },\n" +
+                        "      \"minItems\": 1,\n" +
+                        "      \"uniqueItems\": true\n" +
+                        "    },\n" +
+                        "    \"dimensions\": {\n" +
+                        "      \"type\": \"object\",\n" +
+                        "      \"properties\": {\n" +
+                        "        \"length\": {\n" +
+                        "          \"type\": \"number\"\n" +
+                        "        },\n" +
+                        "        \"width\": {\n" +
+                        "          \"type\": \"number\"\n" +
+                        "        },\n" +
+                        "        \"height\": {\n" +
+                        "          \"type\": \"number\"\n" +
+                        "        }\n" +
+                        "      },\n" +
+                        "      \"required\": [ \"length\", \"width\", \"height\" ]\n" +
+                        "    },\n" +
+                        "    \"warehouseLocation\": {\n" +
+                        "      \"description\": \"Coordinates of the warehouse where the product is located.\",\n" +
+                        "      \"$ref\": \"https://example.com/geographical-location.schema.json\"\n" +
+                        "    }\n" +
+                        "  },\n" +
+                        "  \"required\": [ \"productId\", \"productName\", \"price\" ]\n" +
+                        "}");
+//        JsonSchemaValidator.validate(root);
+    }
+
+    @Test
+    public void testValidateTypeField() throws JsonSchemaValidator.SchemaValidationException {
+        JsonElement root = JsonParser.parseString("{ \"type\": [\"number\", \"bl\"] }");
+        Exception exception = null;
+        try {
+            JsonSchemaValidator.validateTypeField(root.getAsJsonObject());
+        } catch (Exception ex) {
+            exception = ex;
+        }
+        Assert.assertNotNull(exception);
+        Assert.assertEquals(JsonSchemaValidator.SchemaValidationException.class, exception.getClass());
+    }
+
+    @Test
+    public void testValidateOptionalURIField() throws JsonSchemaValidator.SchemaValidationException {
+        JsonElement root = JsonParser.parseString(
+                "{\n" +
+                        "  \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n" +
+                        "  \"$id\": \"https://example.com/product.schema.json\",\n" +
+                        "  \"title\": \"Product\",\n" +
+                        "  \"description\": \"A product from Acme's catalog\",\n" +
+                        "  \"type\": \"object\",\n" +
+                        "  \"properties\": {\n" +
+                        "    \"productId\": {\n" +
+                        "      \"description\": \"The unique identifier for a product\",\n" +
+                        "      \"type\": \"integer\"\n" +
+                        "    }" +
+                        "  }," +
+                        "  \"required\": [\"productId\"]" +
+                        "}");
+        JsonSchemaValidator.validateOptionalURIField("$schema", root.getAsJsonObject());
+    }
+
+
+    @Test
+    public void testValidateObject() throws JsonSchemaValidator.SchemaValidationException {
+        JsonElement root = JsonParser.parseString(
+                "{\n" +
+                        "  \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n" +
+                        "  \"$id\": \"https://example.com/product.schema.json\",\n" +
+                        "  \"title\": \"Product\",\n" +
+                        "  \"description\": \"A product from Acme's catalog\",\n" +
+                        "  \"type\": \"object\",\n" +
+                        "  \"properties\": {\n" +
+                        "    \"productId\": {\n" +
+                        "      \"description\": \"The unique identifier for a product\",\n" +
+                        "      \"type\": \"integer\"\n" +
+                        "    }" +
+                        "  }," +
+                        "  \"required\": [\"productId\"]" +
+                        "}");
+        JsonSchemaValidator.validateObject(root.getAsJsonObject());
+    }
+
+    @Test
+    public void testValidateArray() throws JsonSchemaValidator.SchemaValidationException {
+        JsonElement root = JsonParser.parseString(
+                "{\n" +
+                        "      \"description\": \"Tags for the product\",\n" +
+                        "      \"type\": \"array\",\n" +
+                        "      \"items\": {\n" +
+                        "        \"type\": \"string\"\n" +
+                        "      },\n" +
+                        "      \"minItems\": 1,\n" +
+                        "      \"uniqueItems\": true\n" +
+                        "}");
+        JsonSchemaValidator.validateArray(root.getAsJsonObject());
+    }
+
+    @Test
+    public void testValidateString() throws JsonSchemaValidator.SchemaValidationException {
+        JsonElement root = JsonParser.parseString(
+                "{\n" +
+                        "      \"description\": \"Tags for the product\",\n" +
+                        "      \"type\": \"string\",\n" +
+                        "      \"maxLength\": \"10\",\n" +
+                        "      \"minLength\": \"5\",\n" +
+                        "      \"pattern\": \"nice pattern\"\n" +
+                        "}");
+        JsonSchemaValidator.validateString(root.getAsJsonObject());
+    }
+
+    @Test
+    public void testValidateNumberAndInteger() throws JsonSchemaValidator.SchemaValidationException {
+        JsonElement root1 = JsonParser.parseString(
+                "{\n" +
+                        "      \"description\": \"Tags for the product\",\n" +
+                        "      \"type\": \"number\",\n" +
+                        "      \"multipleOf\": 10.5,\n" +
+                        "      \"minimum\": 6.1,\n" +
+                        "      \"maximum\": 15.5,\n" +
+                        "      \"exclusiveMinimum\": 5,\n" +
+                        "      \"exclusiveMaximum\": 20\n" +
+                        "}");
+        JsonElement root2 = JsonParser.parseString(
+                "{\n" +
+                        "      \"description\": \"Tags for the product\",\n" +
+                        "      \"type\": \"integer\",\n" +
+                        "      \"multipleOf\": 10,\n" +
+                        "      \"minimum\": 6,\n" +
+                        "      \"maximum\": 15,\n" +
+                        "      \"exclusiveMinimum\": 5,\n" +
+                        "      \"exclusiveMaximum\": 20\n" +
+                        "}");
+        JsonSchemaValidator.validateNumberAndInteger(root1.getAsJsonObject());
+        JsonSchemaValidator.validateNumberAndInteger(root2.getAsJsonObject());
+    }
+}
diff --git a/pom.xml b/pom.xml
index eab2eafc..60c30543 100644
--- a/pom.xml
+++ b/pom.xml
@@ -28,7 +28,7 @@
 
   <properties>
     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
-    <javaVersion>7</javaVersion>
+    <javaVersion>11</javaVersion>
   </properties>
 
   <scm>
